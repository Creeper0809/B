#!/usr/bin/env bash
set -euo pipefail

# 스크립트 디렉토리 찾기
script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
root_dir="$(cd "$script_dir/.." && pwd)"
out_dir="$root_dir/build"

# basm 경로 설정 (v2c와 같은 디렉토리)
BASM="$script_dir/basm"
if [[ ! -x "$BASM" ]]; then
  # Windows/Git Bash 환경에서 .exe 확장자 시도
  BASM="$script_dir/basm.exe"
  if [[ ! -x "$BASM" ]]; then
    echo "Error: basm not found in $script_dir" >&2
    exit 1
  fi
fi

# v2 compiler driver build inputs (mirrors v2 smoke harness)
prelude="$root_dir/src/v1/prelude.b"
std0="$root_dir/src/v1/std/std0_sys.b"
std1="$root_dir/src/v1/std/std1_memstrnum.b"
std2="$root_dir/src/v1/std/std2_fileio.b"
core_slice="$root_dir/src/v1/core/slice.b"
core_vec="$root_dir/src/v1/core/vec.b"
core_label="$root_dir/src/v1/core/label_gen.b"
emit_emitter="$root_dir/src/v1/emit/emitter.b"
lex_token="$root_dir/src/v2/lex/token.b"
lex_lexer="$root_dir/src/v2/lex/lexer.b"
parse_expr="$root_dir/src/v2/parse/expr.b"
parse_cond="$root_dir/src/v2/parse/cond.b"
parse_stmt="$root_dir/src/v2/parse/stmt.b"
parse_func="$root_dir/src/v2/parse/func.b"
driver_main="$root_dir/src/v2/driver/main.b"

merged="$out_dir/v2_driver.b"
drv_asm="$out_dir/v2_driver.asm"
drv_obj="$out_dir/v2_driver.o"
drv_bin="$out_dir/v2_driver"

usage() {
  cat <<'USAGE'
Usage: bin/v2c [--stdout-asm] [--run] <input1> [input2 ...] [-- <args...>]

- Builds (if needed) a v2 compiler driver into build/v2_driver
- For each input, runs the driver to generate build/v2_out.asm,
  then assembles+links it to ensure the output ASM is valid.
- Artifacts are saved as:
  build/<name>.v2_out.asm
  build/<name>.v2_out.o
  build/<name>.v2_out_bin

Options:
  --stdout-asm   Print generated ASM to stdout (status messages go to stderr).
  --run          After linking, execute build/<name>.v2_out_bin.

Notes:
  - Any arguments after `--` are passed to the output binary.
USAGE
}

build_driver() {
  mkdir -p "$out_dir"

  cat "$prelude" \
    "$std0" "$std1" "$std2" \
    "$core_slice" "$core_vec" "$core_label" \
    "$emit_emitter" \
    "$lex_token" "$lex_lexer" \
    "$parse_expr" "$parse_cond" "$parse_stmt" "$parse_func" \
    "$driver_main" > "$merged"

  "$BASM" "$merged" -o "$drv_asm" >/dev/null
  # Stage1 heap: basm emits a fixed-size HEAP_SIZE (default 1 MiB).
  # Hosted-v3 builds have grown; bump the driver heap to avoid OOM->NULL deref.
  sed -i 's/%define HEAP_SIZE 1048576/%define HEAP_SIZE 16777216/' "$drv_asm"
  nasm -felf64 "$drv_asm" -o "$drv_obj"
  ld -o "$drv_bin" "$drv_obj"
}

needs_rebuild_driver() {
  if [[ ! -x "$drv_bin" ]]; then
    return 0
  fi

  local newest
  newest="$(
    ls -t \
      "$prelude" \
      "$std0" "$std1" "$std2" \
      "$core_slice" "$core_vec" "$core_label" \
      "$emit_emitter" \
      "$lex_token" "$lex_lexer" \
      "$parse_expr" "$parse_cond" "$parse_stmt" "$parse_func" \
      "$driver_main" \
      "$0" \
      2>/dev/null | head -n 1
  )"

  # If any input is newer than the built driver, rebuild.
  if [[ -n "$newest" && "$newest" -nt "$drv_bin" ]]; then
    return 0
  fi
  return 1
}

if [[ ${1:-} == "-h" || ${1:-} == "--help" ]]; then
  usage
  exit 0
fi

stdout_asm=0
run_bin=0

while [[ $# -gt 0 ]]; do
  case "$1" in
    --stdout-asm)
      stdout_asm=1
      shift
      ;;
    --run)
      run_bin=1
      shift
      ;;
    --)
      shift
      break
      ;;
    -*)
      echo "FAIL: unknown option: $1" >&2
      echo >&2
      usage >&2
      exit 2
      ;;
    *)
      break
      ;;
  esac
done

if [[ $# -lt 1 ]]; then
  usage >&2
  exit 2
fi

# Split inputs and optional run-args: bin/v2c [opts] <inputs...> [-- <args...>]
inputs=()
run_argv=()
mode="inputs"
for a in "$@"; do
  if [[ "$mode" == "inputs" && "$a" == "--" ]]; then
    mode="runargs"
    continue
  fi
  if [[ "$mode" == "inputs" ]]; then
    inputs+=("$a")
  else
    run_argv+=("$a")
  fi
done

if [[ ${#inputs[@]} -lt 1 ]]; then
  usage >&2
  exit 2
fi

if needs_rebuild_driver; then
  build_driver
fi

mkdir -p "$out_dir"

for input in "${inputs[@]}"; do
  if [[ ! -f "$input" ]]; then
    echo "FAIL: input not found: $input" >&2
    exit 2
  fi

  input_abs="$(realpath "$input")"

  name="$(basename "$input")"
  name="${name//[^A-Za-z0-9._-]/_}"

  rm -f "$out_dir/v2_out.asm"
  log="$out_dir/v2c_${name}.log"
  # Workaround: the v2 driver currently can segfault when given absolute
  # --module-root paths. Run from repo root and pass relative roots instead.
  if ! (cd "$root_dir" && "$drv_bin" --module-root ./src/library/v2 --module-root ./src "$input_abs") >"$log" 2>&1; then
    echo "FAIL: v2 driver error for $input" >&2
    cat "$log" >&2
    exit 1
  fi

  if [[ ! -f "$out_dir/v2_out.asm" ]]; then
    echo "FAIL: driver did not create build/v2_out.asm for $input" >&2
    exit 1
  fi

  asm_out="$out_dir/${name}.v2_out.asm"
  obj_out="$out_dir/${name}.v2_out.o"
  bin_out="$out_dir/${name}.v2_out_bin"

  mv "$out_dir/v2_out.asm" "$asm_out"
  nasm -felf64 "$asm_out" -o "$obj_out"
  ld -o "$bin_out" "$obj_out"

  if [[ $stdout_asm -eq 1 ]]; then
    cat "$asm_out" || {
      st=$?
      # Allow piping to tools that exit early (e.g. `head`) without treating it as a failure.
      if [[ $st -ne 141 ]]; then
        exit "$st"
      fi
    }
    echo "OK: $input -> $asm_out" >&2
  else
    echo "OK: $input -> $asm_out"
  fi

  if [[ $run_bin -eq 1 ]]; then
    echo "RUN: $bin_out ${run_argv[*]:-}" >&2
    "$bin_out" "${run_argv[@]}"
  fi
done
