// v2 library: HashMap (bytes key: ptr+len -> u64 value)
//
// Intended for v2-compiled output binaries.

import std.io;
import std.mem;

struct HashMap {
	entries: u64;
	cap: u64;
	len: u64;
};

// Entry layout (40 bytes):
// 0: key_ptr (u64)
// 8: key_len (u64)
// 16: value (u64)
// 24: hash (u64)
// 32: used (u64)

func hashmap_hash(p, n) {
	// FNV-1a 64-bit
	asm {
		mov rax, 14695981039346656037
		mov rcx, rsi
		test rcx, rcx
		jz .done
		xor r8, r8
		.loop:
		movzx r9d, byte [rdi+r8]
		xor rax, r9
		mov r10, 1099511628211
		imul rax, r10
		inc r8
		cmp r8, rcx
		jb .loop
		.done:
	}
	return;
}

func hashmap_round_cap(cap) {
	if (cap < 8) {
		return 8;
	}
	var pow2 = 8;
	while (pow2 < cap) {
		pow2 = pow2 * 2;
	}
	return pow2;
}

func hashmap_entry_ptr(entries, idx) {
	return entries + idx * 40;
}

func hashmap_entries_put(entries, cap, key_ptr, key_len, hash, value) {
	// Returns: 1 if inserted new, 0 if updated existing
	var mask = cap - 1;
	var idx = hash & mask;
	while (1) {
		var e = hashmap_entry_ptr(entries, idx);
		var used = *cast(*u64, e + 32);
		if (used == 0) {
			*cast(*u64, e + 0) = key_ptr;
			*cast(*u64, e + 8) = key_len;
			*cast(*u64, e + 16) = value;
			*cast(*u64, e + 24) = hash;
			*cast(*u64, e + 32) = 1;
			return 1;
		}

		if (*cast(*u64, e + 24) == hash) {
			if (*cast(*u64, e + 8) == key_len) {
				var kp = *cast(*u64, e + 0);
				if (memeq(kp, key_ptr, key_len) == 1) {
					*cast(*u64, e + 16) = value;
					return 0;
				}
			}
		}

		idx = (idx + 1) & mask;
	}
	return 0;
}

func hashmap_entries_get(entries, cap, key_ptr, key_len, hash) {
	// Returns: rax=value (undefined if ok=0), rdx=ok
	var mask = cap - 1;
	var idx = hash & mask;
	while (1) {
		var e = hashmap_entry_ptr(entries, idx);
		var used = *cast(*u64, e + 32);
		if (used == 0) {
			ok = 0;
			return 0;
		}

		if (*cast(*u64, e + 24) == hash) {
			if (*cast(*u64, e + 8) == key_len) {
				var kp = *cast(*u64, e + 0);
				if (memeq(kp, key_ptr, key_len) == 1) {
					ok = 1;
					return *cast(*u64, e + 16);
				}
			}
		}

		idx = (idx + 1) & mask;
	}
	return 0;
}

func hashmap_new(cap) {
	var cap1 = hashmap_round_cap(cap);

	var map = heap_alloc(24);
	if (map == 0) {
		return 0;
	}

	var bytes = cap1 * 40;
	var entries = heap_alloc(bytes);
	if (entries == 0) {
		return 0;
	}
	memset(entries, 0, bytes);

	*cast(*u64, map + 0) = entries;
	*cast(*u64, map + 8) = cap1;
	*cast(*u64, map + 16) = 0;
	return map;
}

func hashmap_put(map, key_ptr, key_len, value) {
	var entries = *cast(*u64, map + 0);
	var cap = *cast(*u64, map + 8);
	var h = hashmap_hash(key_ptr, key_len);
	var inserted = hashmap_entries_put(entries, cap, key_ptr, key_len, h, value);
	if (inserted != 0) {
		*cast(*u64, map + 16) = *cast(*u64, map + 16) + 1;
	}
	return inserted;
}

func hashmap_get(map, key_ptr, key_len) {
	var entries = *cast(*u64, map + 0);
	var cap = *cast(*u64, map + 8);
	var h = hashmap_hash(key_ptr, key_len);
	return hashmap_entries_get(entries, cap, key_ptr, key_len, h);
}

func hashmap_has(map, key_ptr, key_len) {
	hashmap_get(map, key_ptr, key_len);
	if (ok == 0) {
		return 0;
	}
	return 1;
}
