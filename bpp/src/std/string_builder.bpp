// v2 library: StringBuilder (byte buffer, NUL-terminated)
//
// Intended for v2-compiled output binaries.

import std.io;
import std.mem;
import std.conv;

struct StringBuilder {
	ptr: u64;
	len: u64;
	cap: u64; // excluding trailing NUL
};

func sb_new(cap) {
	if (cap < 8) {
		cap = 8;
	}

	var sb = heap_alloc(24);
	if (sb == 0) {
		return 0;
	}

	var buf = heap_alloc(cap + 1);
	if (buf == 0) {
		return 0;
	}

	*cast(*u64, sb + 0) = buf;
	*cast(*u64, sb + 8) = 0;
	*cast(*u64, sb + 16) = cap;
	*cast(*u8, buf) = 0;
	return sb;
}

func sb_clear(sb) {
	*cast(*u64, sb + 8) = 0;
	var p = *cast(*u64, sb + 0);
	*cast(*u8, p) = 0;
	return 0;
}

func sb_len(sb) {
	return *cast(*u64, sb + 8);
}

func sb_ptr(sb) {
	return *cast(*u64, sb + 0);
}

func sb_reserve(sb, add) {
	var len = *cast(*u64, sb + 8);
	var cap = *cast(*u64, sb + 16);
	var need = len + add;
	if (need <= cap) {
		return 0;
	}

	var new_cap = cap;
	if (new_cap == 0) {
		new_cap = 8;
	}
	while (new_cap < need) {
		new_cap = new_cap * 2;
	}

	var new_buf = heap_alloc(new_cap + 1);
	if (new_buf == 0) {
		return 0;
	}

	var old_buf = *cast(*u64, sb + 0);
	memcpy(new_buf, old_buf, len);
	*cast(*u8, new_buf + len) = 0;

	*cast(*u64, sb + 0) = new_buf;
	*cast(*u64, sb + 16) = new_cap;
	return 0;
}

func sb_append_bytes(sb, p, n) {
	sb_reserve(sb, n);

	var len = *cast(*u64, sb + 8);
	var dst = *cast(*u64, sb + 0) + len;
	memcpy(dst, p, n);
	len = len + n;
	*cast(*u64, sb + 8) = len;
	*cast(*u8, *cast(*u64, sb + 0) + len) = 0;
	return 0;
}

func sb_append_cstr(sb, s) {
	var n = strlen(s);
	sb_append_bytes(sb, s, n);
	return 0;
}

func sb_append_u64_dec(sb, x) {
	var p = itoa_u64_dec(x);
	sb_append_bytes(sb, p, n);
	return 0;
}
