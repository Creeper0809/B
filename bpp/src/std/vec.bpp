// v2 library: Vec (push-only, u64 items)
//
// Intended for v2-compiled output binaries.

import std.io;
import std.mem;

struct Vec {
	ptr: u64;
	len: u64;
	cap: u64;
};

func vec_new(cap) {
	// Returns: Vec*
	var v = heap_alloc(24);
	if (v == 0) {
		return 0;
	}

	var bytes = cap * 8;
	var buf = heap_alloc(bytes);
	if (buf == 0) {
		return 0;
	}

	*cast(*u64, v + 0) = buf;
	*cast(*u64, v + 8) = 0;
	*cast(*u64, v + 16) = cap;
	return v;
}

func vec_len(v) {
	return *cast(*u64, v + 8);
}

func vec_get(v, i) {
	var buf = *cast(*u64, v + 0);
	return *cast(*u64, buf + i * 8);
}

func vec_push(v, item) {
	// Returns: new length (1-based count)
	var len = *cast(*u64, v + 8);
	var cap = *cast(*u64, v + 16);
	if (len >= cap) {
		var new_cap = cap;
		if (new_cap == 0) {
			new_cap = 1;
		}
		while (new_cap <= len) {
			new_cap = new_cap * 2;
		}

		var new_buf = heap_alloc(new_cap * 8);
		if (new_buf == 0) {
			return 0;
		}

		var old_buf = *cast(*u64, v + 0);
		memcpy(new_buf, old_buf, len * 8);
		*cast(*u64, v + 0) = new_buf;
		*cast(*u64, v + 16) = new_cap;
	}

	var buf2 = *cast(*u64, v + 0);
	*cast(*u64, buf2 + len * 8) = item;
	len = len + 1;
	*cast(*u64, v + 8) = len;
	return len;
}

func vec_pop(v) {
	// Returns: popped item (or 0 if empty)
	var len = *cast(*u64, v + 8);
	if (len == 0) {
		return 0;
	}
	len = len - 1;
	var buf = *cast(*u64, v + 0);
	var item = *cast(*u64, buf + len * 8);
	*cast(*u64, v + 8) = len;
	return item;
}
