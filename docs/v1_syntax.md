# v1 Syntax (현재 구현 기준)

이 문서는 **현재 v1 컴파일 파이프라인(드라이버 + 파서/코드젠)** 이 실제로 받아들이는 문법을 정리합니다.

- 입력 언어: v1(부트스트랩 컴파일러가 컴파일하는 소스)
- 엔트리포인트: `_start`가 `main()`을 호출하고, `main()`의 반환값을 프로세스 종료 코드로 사용합니다.

## 1) 렉시컬(토큰) 규칙

### 공백/줄
- 공백/탭/CR/LF는 토큰 사이에서 무시됩니다.
- 줄 번호는 `\n`을 만날 때 증가합니다.

### 주석
- 한 줄 주석: `//` 부터 줄 끝까지 무시됩니다.

### 식별자(IDENT)
- 형태: `[_A-Za-z][_A-Za-z0-9]*`
- 키워드와 동일하면 키워드 토큰으로 분류됩니다.

### 정수(INT)
- 형태:
  - 10진수: `[0-9]+`
  - 16진수: `0x[0-9A-Fa-f]+` (또는 `0X...`)

### 문자열/문자 리터럴
- 문자열: `"..."` / 문자: `'...'`
- `\\`가 나오면 다음 1바이트를 스킵하는 형태로 이스케이프를 허용합니다.
- 문자열 리터럴은 아직 표현식으로 **지원하지 않습니다**. (렉서는 토큰화하지만, 파싱 단계에서 에러)
- 문자 리터럴은 단일 문자(또는 단일 이스케이프) 형태에 한해 **정수(INT)로 변환되어 표현식에서 사용 가능합니다**.
  - 예: `'a'` (97), `'\n'` (10), `'\t'` (9), `'\0'` (0), `'\\'` (92), `'\''` (39)

### 연산자/구분자
- 단일 문자: `(` `)` `{` `}` `[` `]` `;` `,` `.` `+` `-` `*` `/` `%` `=` `<` `>` `&` `|` `^` `~` `!`
- 2문자 연산자: `&&` `||` `==` `!=` `<=` `>=` `<<` `>>` `->`

주의:
- 위 목록은 **렉서가 토큰으로 인식하는 기호**를 나열한 것입니다.
- 이 중 일부(예: `->`, `.`)는 현재 파서/코드젠에서 의미를 부여하지 않아 사용하면 에러가 납니다.

## 2) 프로그램 구조

현재 드라이버가 호출하는 최상위 파서는 **`const` 선언과 함수 정의들의 나열**을 허용합니다.

```
program := (const_decl | func_decl)* EOF
const_decl := 'const' IDENT '=' INT ';'
```

- `const`는 전역(컴파일 단위) 정수 상수(u64)입니다.
- 현재 v1은 우변을 `INT` 1개로만 제한합니다(상수식/타입은 v2에서 확장).
- `const` 이름에 대한 대입(`NAME = ...;`)은 에러입니다.

## 3) 함수

### 함수 정의
```
func_decl := 'func' IDENT '(' [param_list] ')' '{' stmt* '}'
param_list := IDENT (',' IDENT)*
```

- 매개변수 최대 6개
- 변수/매개변수 저장 모델(현재 구현):
  - `IDENT`는 모두 **함수 로컬 스택 슬롯**로 취급됩니다(선언 필요 없음).
  - 함수 진입 시 인자 레지스터(rdi,rsi,rdx,rcx,r8,r9)는 같은 이름의 로컬 슬롯에 spill 됩니다.
  - 로컬은 **재귀 호출에 안전**합니다(각 호출이 독립적인 스택 프레임을 가짐).
  - 현재는 단순화를 위해 각 함수가 고정 크기 로컬 프레임(1024 바이트)을 확보합니다.

### 함수 호출(표현식)
```
call := IDENT '(' [arg_list] ')'
arg_list := expr (',' expr)*
```

- 인자 최대 6개
- 반환값은 표현식 값(rax)을 사용합니다.

## 4) 문장(Statements)

함수 본문 `{ ... }` 내부에서 아래 문장들을 지원합니다.

### 블록
- 블록은 `if`/`else`/`while`에서만 사용합니다.
- 독립적인 "중괄호 블록"(예: `{ stmt* }`만 단독)은 현재 문장으로 정의되어 있지 않습니다.

### if / else
```
stmt := 'if' '(' cond ')' '{' stmt* '}' ['else' ( 'if' ... | '{' stmt* '}' )]
```

- `else if (...) { ... }` 형태를 지원합니다.

### while
```
stmt := 'while' '(' cond ')' '{' stmt* '}'
```

### break / continue
```
stmt := 'break'    ['(' INT ')'] ';'
stmt := 'continue' ['(' INT ')'] ';'
```

- 기본은 1단계 break/continue
- `(num)`을 주면 바깥 루프까지 점프합니다.

### return
```
stmt := 'return' [expr] ';'
```

- `return;` 은 0을 반환하는 동작으로 취급됩니다.

### 대입
```
stmt := IDENT '=' expr ';'
```

- 기본적으로 대입 대상은 **현재 함수의 로컬 슬롯**로 취급됩니다(선언 필요 없음).
- 단, 아래의 `alias`로 등록된 이름은 **레지스터**로 취급됩니다.

### 레지스터 alias
```
stmt := 'alias' REG ':' IDENT ['=' expr] ';'
REG := 'rdi'|'rsi'|'rdx'|'rcx'|'r8'|'r9'|'r10'|'r11'
```

- 같은 함수 안에서 `IDENT`를 특정 레지스터에 별칭으로 매핑합니다.
- 이후 `IDENT`의 읽기/쓰기(대입)는 해당 레지스터로 컴파일됩니다.
- 스코프는 **함수 단위**입니다(함수 밖/top-level alias는 없음).

### 메모리 store (ptr8/ptr64)
```
stmt := ('ptr8'|'ptr64') '[' addr ']' '=' expr ';'
addr := expr
```

- `ptr8[...]`는 1바이트 store (`mov byte [addr], al`)
- `ptr64[...]`는 8바이트 store (`mov qword [addr], rax`)
- `[...]` 안의 값은 항상 **"주소 값"**(정수)로 해석됩니다.
- 로컬 슬롯의 주소가 필요하면 `addr[IDENT]`를 사용합니다.
  - 예: `p = addr[x]; ptr64[p] = 7;`

### 표현식 문장
```
stmt := expr ';'
```

- 표현식 결과는 버려집니다.

### 인라인 asm 블록
```
stmt := 'asm' '{' ... '}'
```

- `asm { ... }` 내부의 내용은 **그대로 출력 NASM 어셈블리로 삽입**됩니다.
- 세미콜론이 필요 없습니다.
- 주의: 삽입되는 어셈블리는 현재 함수 문맥(레지스터/스택 상태)에 영향을 줄 수 있습니다.

## 5) 조건식(Conditions)

`if (...)` 와 `while (...)` 괄호 안은 **조건식 문법**을 사용합니다.

```
cond := cond_or
cond_or  := cond_and ( '||' cond_and )*
cond_and := cond_not ( '&&' cond_not )*
cond_not := '!' cond_not | cond_atom
cond_atom := '(' cond ')' | expr
```

- `&&`, `||` 는 **조건식에서만** 지원합니다(표현식 `expr` 문법에는 없음).
- 단락 평가(short-circuit)를 합니다.
- `expr` 값은 0이면 false, 0이 아니면 true로 취급합니다.

## 6) 표현식(Expressions)

우선순위(높음 → 낮음):

1. factor: `INT` | `IDENT` | `call` | `addr` | `ptr_load` | `(` expr `)`
2. unary: `+` `-` `~` `!`
3. term: `*` `/` `%`
4. additive: `+` `-`
5. shift: `<<` `>>`
6. relational: `<` `>` `<=` `>=`
7. equality: `==` `!=`
8. bitwise and/xor/or: `&` `^` `|`

주의:
- 논리 연산자 `&&`, `||` 는 표현식에 없습니다.
- 정수는 10진/16진(`0x...`)을 지원합니다.

### ptr8/ptr64 load
`expr`의 factor에서 아래 형태를 지원합니다.

```
factor := ... | ('ptr8'|'ptr64') '[' addr ']' 
addr := expr
```

- `ptr8[...]`는 1바이트 load 후 0-확장하여 값을 만듭니다.
- `ptr64[...]`는 8바이트 load 값을 만듭니다.

### addr[IDENT] (로컬 슬롯 주소 얻기)
로컬 슬롯의 주소(포인터 값)를 얻기 위해 아래 형태를 지원합니다.

```
factor := ... | 'addr' '[' IDENT ']'
```

- `addr[x]`는 로컬 변수 `x`의 스택 슬롯 주소를 푸시합니다.
- 예: `p = addr[x]; return ptr64[p];`

## 7) 현재 제한사항 요약

- 최상위는 `func`/`const`만 허용(전역 `var` 선언 등은 파이프라인에서 미지원)
- 로컬은 함수 단위 1-네임스페이스(블록 스코프 없음)
- 로컬 프레임은 현재 고정 크기(1024 바이트)로 확보
- 함수 인자/호출 인자 최대 6개
- 문자열 리터럴은 렉서가 토큰화하지만, 현재 파서는 언어 기능으로 처리하지 않음
- `->`, `.` 등 일부 토큰은 렉서가 인식하지만, 파서/코드젠에서 의미를 부여하지 않음

## 8) 예제

### 최소 프로그램
```b
func main() {
  return 0;
}
```

### 함수 호출 + 인자
```b
func add(a, b) {
  return a + b;
}

func main() {
  return add(3, 4);
}
```

### if/while + break/continue
```b
func main() {
  x = 0;
  while (x < 10 && !(x == 7)) {
    x = x + 1;
    if (x == 3) { continue; }
    if (x == 9) { break; }
  }
  return x;
}
```
