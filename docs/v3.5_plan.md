# v3.5 컴파일러 개발 계획

## 목표
v2c로 컴파일 가능하면서 **v3의 모든 기능을 지원**하는 컴파일러 작성

## 핵심 차별점
- **offsetof 버그 우회**: 수동 오프셋 계산 또는 런타임 헬퍼 사용
- **슬라이스 필드 접근 완전 지원**: `.len`, `.ptr` 직접 구현
- **v2c 제약 준수**: 제네릭/comptime 없이 구현

## 파일 구조
```
src/v3.5/
├── main.b          # 드라이버
├── lexer.b         # 토큰화 (500줄)
├── parser.b        # 파싱 (1000줄)
├── ast.b           # AST 정의 (300줄)
├── typecheck.b     # 타입 체크 (800줄)
├── ir.b            # IR 정의 (200줄)
├── lowering.b      # AST → IR (600줄)
├── codegen.b       # IR → x86-64 (600줄)
└── util.b          # 유틸리티 (200줄)
```
**총 예상**: ~4000줄

## 단계별 구현

### Stage 1: 기반 구조 (1-2일)
- [x] 프로젝트 셋업
- [ ] Lexer: 모든 토큰 인식
- [ ] Parser: 기본 문법 (변수, 함수, 표현식)
- [ ] 최소 AST 정의

**검증**: `func main() { return 42; }` 파싱 성공

### Stage 2: 타입 시스템 (2-3일)
- [ ] 기본 타입: u8~u64, i8~i64, bool
- [ ] 슬라이스: `[]T` 타입 + `.len`/`.ptr` 필드
- [ ] 포인터: `*T`, `*T?`
- [ ] struct, enum
- [ ] 배열: `[N]T`

**검증**: struct/슬라이스 타입 체크 통과

### Stage 3: 표현식 완성 (1일)
- [ ] 산술/비트/비교/논리 연산
- [ ] 복합 대입, 증감
- [ ] 인덱싱, 필드 접근
- [ ] 함수 호출

**검증**: 복잡한 표현식 평가

### Stage 4: 제어 흐름 (1-2일)
- [ ] if/else
- [ ] while, for
- [ ] foreach (슬라이스/배열)
- [ ] switch
- [ ] break/continue/return

**검증**: 루프, 조건문 동작

### Stage 5: IR + Codegen (2-3일)
- [ ] IR 정의 (SSA 형태)
- [ ] AST → IR lowering
- [ ] x86-64 코드 생성
- [ ] 레지스터 할당 (간단한 linear scan)

**검증**: 실행 가능한 바이너리 생성

### Stage 6: 고급 기능 (2-3일)
- [ ] defer
- [ ] 변수 섀도잉
- [ ] impl 블록 + 메서드
- [ ] 인라인 어셈블리
- [ ] 함수 포인터

**검증**: v3 기능 전체 동작

### Stage 7: 모듈 시스템 (1-2일)
- [ ] import 처리
- [ ] 접근 제어 (public/private)
- [ ] 다중 파일 컴파일

**검증**: 2개 이상 모듈로 프로그램 작성

---

## 현재 진행 상황 (2026-01-10)

**Stage**: 준비 단계
**다음 작업**: Lexer 구현 시작

---

## 핵심 설계 결정

### 1. 슬라이스 레이아웃
```b
struct Slice_u8 {
    ptr: *u8;
    len: u64;
}
```
- 컴파일러가 자동으로 struct로 취급
- `.len`, `.ptr` 접근은 일반 필드 접근으로 lowering

### 2. offsetof 우회
```b
// offsetof 대신 수동 계산
func get_field_offset_Player_hp() -> u64 {
    var dummy: Player;
    var base: u64 = cast(u64, &dummy);
    var field: u64 = cast(u64, &dummy.hp);
    return field - base;
}
```

### 3. 타입 표현
```b
enum TypeKind {
    TYPE_U8, TYPE_U16, TYPE_U32, TYPE_U64,
    TYPE_I8, TYPE_I16, TYPE_I32, TYPE_I64,
    TYPE_BOOL, TYPE_F32, TYPE_F64,
    TYPE_PTR, TYPE_SLICE, TYPE_ARRAY,
    TYPE_STRUCT, TYPE_ENUM, TYPE_FUNC,
}

struct Type {
    kind: TypeKind;
    // ... elem_type, fields 등
}
```

### 4. IR 형태
```b
enum IROp {
    IR_CONST, IR_LOAD, IR_STORE,
    IR_ADD, IR_SUB, IR_MUL, IR_DIV,
    IR_CALL, IR_RET,
    IR_BR, IR_BR_IF,
    // ...
}

struct IRInstr {
    op: IROp;
    dst: u64;   // 가상 레지스터
    src1: u64;
    src2: u64;
}
```

---

## 예상 일정

**총 소요**: 10-14일 (풀타임 기준)

- Stage 1: 2일
- Stage 2: 3일
- Stage 3: 1일
- Stage 4: 2일
- Stage 5: 3일
- Stage 6: 3일
- Stage 7: 2일
- 디버깅: 2-3일

**최종 목표일**: 2026-01-24
