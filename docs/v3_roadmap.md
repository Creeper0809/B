# v3 Roadmap (Draft)

이 문서는 v2로 v3 컴파일러를 작성하기 위해, v3에서 목표로 하는 **현대적인 문법/기능**과
그걸 가능하게 하는 **컴파일러 구조(AST → IR → 코드젠)** 전환 계획을 한 곳에 모아 둔 문서입니다.

원칙:
- v3 컴파일러는 **v2로 구현**한다(= v2가 컴파일할 수 있는 범위 안에서 점진적으로 만든다).
- v3는 v2의 MVP를 깨지지 않게 유지하면서, “현대적 언어에서 기대하는 표현력”을 단계적으로 확장한다.
- v3의 새 기능은 가능하면 “문법만 추가”가 아니라, **AST/타입/IR 단계까지 의미가 분명한 형태**로 설계한다.

---

## 0) v3의 큰 목표(요약)

- [ ] **AST 기반 프론트엔드**: 토큰 → 파싱 → AST 생성(오류 복구 포함)
- [ ] **IR 기반 미들엔드**: AST → IR lowering, 간단한 최적화/검증 패스
- [ ] **타입 시스템 확장**: 기본 타입 + 사용자 정의 타입 + 제네릭 + (선택) trait/constraint
- [ ] **표준 라이브러리 기반**: String/Slice/Vec/HashMap 등(최소 API부터)

---

## 1) 문법/표면 언어(Modern Surface Syntax)

### 1.1) 키워드/토큰 정리

v2는 일부 키워드를 IDENT 텍스트 비교로 처리합니다. v3에서는 파서 복잡도를 줄이기 위해 키워드를 토큰으로 승격합니다.

- [ ] 키워드 토큰화: `import`, `enum`, `struct`, `switch`, `for`, `foreach` 등
- [ ] 예약어 정책 명문화(식별자로 사용 가능한지/불가능한지)

### 1.2) 타입 표기/선언 문법 개선

v2의 `var x: Type;` 스타일은 유지하되, “현대적” 선언 편의 문법을 추가합니다.

- [ ] 타입 추론 초기화: `var x := expr;` (또는 `var x = expr;`에서 `: Type` 생략 허용)
- [ ] 함수 시그니처에 반환 타입 표기 도입: `func f(x: T) -> U { ... }`
- [ ] `bool` 타입(조건/논리 연산이 표현식에서 자연스럽게 동작)
- [ ] `&&`/`||`를 expr로 승격(현대적 기대치: 조건식 전용이 아니라 표현식에서 사용)

### 1.2.5) 암호학/알고리즘 표준 연산자: 비트 회전(Rotate)

SHA-256/ChaCha20/AES류에서 회전은 매우 빈번하다. C처럼 매번 매크로로 쓰지 않도록,
v3에서는 회전을 **언어 표준 연산자**로 제공한다.

- [ ] 연산자 추가
	- [ ] `x <<< n` : left rotate (ROL)
	- [ ] `x >>> n` : right rotate (ROR)
	- [ ] 주의: Basm의 `>>>`는 Java의 unsigned shift가 아니라 **rotate** 의미로 고정
- [ ] 적용 대상: 정수 타입(`u32/u64` 등)만 허용, 회전 폭은 타입 비트폭으로 mod 처리
- [ ] 파서/우선순위: `<<`/`>>`와 동일한 레벨(shift)로 취급(정책 확정)
- [ ] lowering: `std.rotl/rotr` intrinsic 호출 또는 x86-64 `rol/ror`로 직접 코드젠

### 1.2.6) 시스템 해킹/극한 최적화 문법(해커 팩)

기존 언어들이 라이브러리/매크로로 처리하던 low-level 패턴을 문법/연산자로 승격해
“기계 제어 + 투명성”을 언어의 개성으로 만든다.

- [ ] 강제 Tail Call: `return tail f(args...);`
	- [ ] 의미: `CALL`이 아니라 `JMP`로 전환하여 스택을 쌓지 않음(상태 머신/VM용)
	- [ ] 제약(MVP):
		- [ ] 타깃 함수 시그니처(인자/리턴)가 호환되는 경우에만 허용
		- [ ] `defer`/스코프 종료 훅과의 상호작용 정책 확정(권장: tail-call은 defer 실행 후에만 허용 또는 금지)
	- [ ] IR/lowering: `musttail` 같은 플래그로 유지 → 백엔드에서 `jmp`로 내리기

- [ ] 정수 비트 슬라이싱: `x[hi:lo]`
	- [ ] 의미: 정수에서 특정 비트 구간을 추출(예: `instruction[31:26]`)
	- [ ] 적용 대상: 정수 타입만 허용
	- [ ] 제약(MVP): `hi`/`lo`는 컴파일 타임 상수(또는 최소한 범위 체크 가능해야 함)
	- [ ] lowering: `shift + mask`로 기본 구현, (후순위) x86 `bextr` 등으로 최적화

- [ ] Raw/Unsafe 메모리 연산자: `$`
	- [ ] 목표: “안전장치 해제”를 코드에서 한눈에 보이게 하는 강한 마커
	- [ ] 문법(안):
		- [ ] `$ptr` : raw pointer load/store에서 추가 체크(널/정렬 등)를 생략
		- [ ] `arr$i` : bounds check 없는 인덱싱(load/store)
	- [ ] 제약(MVP): 적용 범위/타입을 제한해서 의미를 명확히(예: 포인터/배열/슬라이스만)
	- [ ] 디버그 모드 정책: 디버그에서는 trap을 넣을지, 완전 생략할지(택1)

### 1.3) 구조체/열거형 리터럴(표현식)

v2에서는 “struct 리터럴 expression”이 없고, 선언 전용 brace-init만 있습니다.
v3에서는 값 생성/전달을 자연스럽게 하기 위해 리터럴을 목표로 합니다.

- [ ] 구조체 리터럴 expr:
	- [ ] named: `Pair{ a: 1, b: 2 }`
	- [ ] positional(선택): `Pair{ 1, 2 }`
- [ ] enum 값 생성 방식 정리(예: `Color::Red` 또는 `Color.Red` 중 택1)

### 1.4) 메서드/네임스페이스(읽기 좋은 API)

- [ ] 메서드 호출 설탕(sugar): `x.f(y)` ↔ `f(x, y)`
- [ ] `impl Type { ... }` 블록(메서드/연관 함수 묶기)
- [ ] visibility: `pub`(모듈 경계에서 API 정리)

### 1.5) 자원 관리: `defer` (필수)

v2에서 가장 불편했던 점(리소스 누수/`malloc/free` 쌍 누락)을 언어 차원에서 줄이기 위한 기능.

- [ ] Go/Zig 스타일의 `defer <stmt>;`
- [ ] 스코프 종료 시 역순 실행 보장
	- [ ] `return`/`break`/`panic` 등 “조기 종료”에서도 실행
	- [ ] `defer`는 현재 스코프에만 걸리는지(함수 스코프 vs 블록 스코프) 정책 확정

### 1.6) FFI (Foreign Function Interface) 명시화 (필수)

v2의 암묵적 extern 호출을 정리하고, C ABI/플랫폼을 명시해서 libc/외부 라이브러리 연동을 쉽게 한다.

- [ ] `extern "C" func ...;` 문법
- [ ] 호출 규약 지정(최소):
	- [ ] `extern "sysv"` (System V AMD64)
	- [ ] `extern "win64"` (Windows x64)
- [ ] extern 함수 선언만 허용 vs extern 블록 허용(택1)
- [ ] 심볼 이름 매핑 정책(기본은 그대로, 필요 시 `link_name` 같은 속성 추가)
- [ ] MVP 정책: 커스텀 레지스터 ABI(`@reg`)는 **`extern` 함수(FFI) 전용**으로만 허용

### 1.7) 조건부 컴파일(Conditional Compilation) (필수)

std/런타임을 OS별로 나누기 위해 컴파일 타임 분기 수단이 필요.

- [ ] 문법 옵션 중 택1:
	- [ ] `#if target_os == "linux" { ... }`
	- [ ] `@[cfg(linux)]` (attribute)
- [ ] 지원 대상 최소: `target_os` (`linux`/`windows`)
- [ ] 분기 범위: 선언/함수/블록 레벨 중 어디까지 허용할지 확정

### 1.8) 일급 함수: 함수 포인터 & (선택) 클로저

제네릭만으로는 비교 함수/콜백 전달이 불편하므로 함수를 값으로 다룬다.

- [ ] 함수 포인터 타입
	- [ ] 타입 표기: `func(i32, i32) -> bool` 또는 `fn(i32, i32) -> bool` 중 택1
	- [ ] 변수에 함수 주소 저장
	- [ ] 간접 호출(예: `call reg`) 코드젠
- [ ] 캡처 없는 익명 함수(선택)
	- [ ] `|x| x+1` 또는 `fn(x) { ... }` 등 문법(후에 확정)
- [ ] 클로저(캡처 있음) (후순위)
	- [ ] 캡처 레이아웃/수명 모델/호출 규약까지 포함한 설계 필요

### 1.9) 보안 프리미티브: `secret` (unique)

암호학/보안 코드에서 “키/시크릿 메모리”를 안전하게 다루기 위한 언어 차원의 지원.
핵심은 **dead store elimination(DSE)로 인해 zeroize가 제거되는 문제를 원천 차단**하는 것.

- [ ] 문법: `secret` 키워드(변수/타입 수식)
	- [ ] 예: `var key: secret [32]u8 = ...;`
- [ ] 의미(MVP): `secret` 변수는 스코프 종료 시 반드시 0으로 덮어쓰기(zeroize)
	- [ ] `return/break/panic` 등 조기 종료에도 실행
	- [ ] 최적화에 의해 제거되지 않도록 보장(volatile store 또는 전용 intrinsic로 lowering)
- [ ] 제약(초기): 스택 로컬부터 지원, 이후 힙/구조체 필드로 확장

### 1.9.5) 성능/보안 계약: `nospill` (레지스터 거주 보장)

극한 성능 루프(메모리 접근 최소화) 또는 보안상 “스택/메모리에 절대 남으면 안 되는 값”에 대해,
해당 변수가 **스필(spill)되어 메모리에 내려가면 컴파일 에러**를 내는 강한 계약 기능.

- [ ] 문법(안): `nospill var x: T = expr;`
	- [ ] 예:
		- [ ] `nospill var r1: u64 = 0;`
		- [ ] `nospill var r2: u64 = 1;`
- [ ] 의미(MVP)
	- [ ] `nospill` 변수는 레지스터에만 존재해야 함(스택 슬롯 할당 금지)
	- [ ] 레지스터 부족 등으로 spill이 필요해지면 **컴파일 에러**
- [ ] 구현 포인트
	- [ ] IR에서 “nospill 값”을 구분 가능하게 태깅(alloca 금지, spill 금지)
	- [ ] 레지스터 할당기(linear-scan 등)가 이 제약을 강제
	- [ ] 에러 메시지: 어떤 변수/어떤 구간에서 레지스터가 부족했는지 위치 정보 포함

### 1.10) 메타프로그래밍: `comptime` (unique)

런타임 오버헤드 없이 테이블/상수를 생성하기 위해, 제한적 컴파일 타임 실행을 제공.
Zig의 `comptime`을 벤치마킹하되, v3의 “AST/IR 구조”에 맞게 최소 기능부터 도입.

- [ ] 문법(안): `const X = comptime f(...);`
	- [ ] 예: `const CRC_TABLE = comptime gen_crc_table();`
- [ ] 지원 범위(MVP): 상수/배열/구조체 등 “정적 데이터로 내릴 수 있는 값”만 허용
- [ ] 구현 전략(택1):
	- [ ] AST/IR 상수 평가기(const-eval)로 실행(권장)
	- [ ] (후순위) v2 런타임/인터프리터 재사용 형태의 내장 실행기
- [ ] 실패 모드: comptime에서 허용되지 않는 연산(시스템콜/힙/IO 등)은 컴파일 에러

### 1.11) Inline ASM 문법 개선(alias 연결 + 레지스터 치환)

v2의 `asm { ... }`는 문자열을 그대로 내보내기 때문에, 레지스터를 바꾸면 asm 텍스트도 같이 고쳐야 한다.
v3에서는 “alias로 선언된 변수”만 inline asm에 연결하고, 텍스트에서 레지스터 이름을 자동 치환한다.

- [ ] 문법(안): `asm(alias_var1, alias_var2, ...) { ... }`
	- [ ] 인자로는 **alias 된 변수만 허용**(일반 로컬/전역은 금지)
	- [ ] 미지정 alias를 `{name}`로 참조하면 컴파일 에러
- [ ] 치환 규칙: 블록 내부 텍스트의 `{var_name}`을 해당 alias의 실제 레지스터 이름(`rax`, `rbx` 등)으로 치환
	- [ ] 예: `mov {tmp}, 0` (tmp가 `r10` alias면 `mov r10, 0` 출력)
- [ ] 목적: 레지스터 변경 시 asm 코드 수정 최소화 + 가독성 향상

---

## 2) 타입 시스템(Types)

### 2.1) 기본 타입 확장

- [ ] 정수군 명시 확장(최소): `u8/u16/u32/u64`, `i8/i16/i32/i64`
- [ ] `usize/isize`(플랫폼 크기) 도입 여부 결정
- [ ] 포인터: `*T` 유지 + `null`/`0` 정책 명확화

### 2.1.5) 타입 별칭(Type Alias) (필수)

복잡한 타입(특히 제네릭) 가독성을 위해 별칭을 제공.

- [ ] 문법: `type MyInt = u64;`
- [ ] 함수 타입 별칭: `type Callback = func(i32) -> void;`
- [ ] 별칭은 “새 타입”이 아니라 “동일 타입 이름”인지(= alias) 정책 명확화

### 2.2) 참조/슬라이스/배열/문자열

- [ ] 슬라이스 타입을 언어 레벨로 표준화: `Slice[T]` 또는 `[]T` 중 택1
	- MVP는 기존 레이아웃(`[ptr:u64][len:u64]`) 호환을 유지
- [ ] 고정 배열 타입 표기: `[N]T` (또는 v2 스타일의 `var a[N]`를 타입으로도 일반화)
- [ ] 문자열 타입: `str`(불변 뷰) + `String`(소유) 같이 2레벨로 갈지 결정

### 2.3) 대수적 데이터 타입(선택)

현대적 언어에서 자주 쓰는 “옵셔널/에러” 표현을 타입으로 넣습니다.

- [ ] `Option[T]` (또는 `T?`) 문법/표준 타입
- [ ] `Result[T, E]` + `try`/`?` 연산자(선택)
- [ ] `match` 패턴 매칭(선택)

### 2.4) 기계 제어: 커스텀 레지스터 ABI 표기(`@reg`) (unique)

특정 환경(커널/부트로더/쉘코드/특수 ABI)에서 “인자/리턴 레지스터를 직접 지정”할 수 있게 한다.

- [ ] 문법(안): 파라미터/리턴에 레지스터 어노테이션
	- [ ] 예: `func syscall_write(fd @ rdi: i32, buf @ rsi: *u8, len @ rdx: u64) -> @rax u64 { ... }`
	- [ ] 예: `func weird_call(val @ r10: u64) { ... }`
- [ ] 제약(MVP): `@reg`는 **`extern` 함수(FFI)에서만 허용** (일반 함수에서는 금지)
- [ ] 이유: 일반 함수까지 허용하면 호출마다 레지스터 셔플링/표준 ABI 파손 문제가 커짐
- [ ] ABI 상호작용: `extern`/FFI와 충돌 시 우선순위/에러 규칙 명확화
- [ ] 코드젠: prologue/epilogue 및 caller/callee-saved 규칙과의 관계를 문서화

---

## 3) 제네릭(Generics)

목표: v3는 컴파일러/표준 라이브러리 구현을 위해 제네릭이 필요합니다.

권장 문법(안): Go 스타일에 가까운 타입 파라미터(대괄호).

```b
func id[T](x: T) -> T { return x; }
struct Vec[T] { ptr: *T; len: usize; cap: usize; }
```

- [ ] 제네릭 함수: `func f[T, U](...) -> ...`
- [ ] 제네릭 타입: `struct Vec[T] { ... }`
- [ ] 제네릭 인스턴스화 전략
	- [ ] monomorphization(템플릿처럼 타입별 코드 생성)
	- [ ] (후순위) dictionary/boxed 방식 고려
- [ ] 타입 추론(호출 시 타입 인자 생략) 우선 지원
- [ ] (선택) 제약/트레이트
	- [ ] `trait Eq { ... }`
	- [ ] `func f[T: Eq](x: T) -> bool`

---

## 4) 컨트롤 플로우/표준 루프/컨테이너

### 4.1) for/foreach 정교화

v2의 `foreach`는 구현 단순화를 위해 **`Slice*`의 byte 순회**만 지원합니다.
(v2에서 `Slice`는 메모리 상 `[ptr:u64][len:u64]` 레이아웃을 가정)

v3 목표:
- [ ] `foreach`가 요소 폭/타입을 알 수 있을 때(예: `u64` 배열/슬라이스) 요소 단위로 순회
- [ ] `foreach` 대상 확장: 로컬 배열 `var a[N]` / (향후) 타입드 컨테이너
- [ ] 루프 변수 선언 문법 확정: `foreach (var x in expr) { ... }` 또는 `foreach (x in expr) { ... }`
- [ ] iterator 프로토콜(선택): `for (x in iter(expr)) { ... }` 같은 형태로 일반화

### 4.2) switch/match

- [ ] `switch`는 유지하되, enum/상수에 대한 표준 사용 패턴 문서화
- [ ] (선택) `match` 도입 시 `switch`와 역할 분담 정리

---

## 5) 모듈/패키지/빌드(현대적 개발 흐름)

- [ ] import를 “파일 include”가 아니라 “모듈/패키지” 단위로 다루기
- [ ] 모듈 경로/가시성 규칙 명확화(`pub` 기본 단위)
- [ ] 빌드 단위(패키지)와 캐시(증분 컴파일) 고려(후순위)

---

## 6) 컴파일러 구조 전환: AST → IR

v2는 구현 단순화를 위해 “파싱하면서 즉시 코드젠(emit)”에 가깝습니다.
v3 컴파일러는 구조적으로 아래 단계를 갖는 것을 목표로 합니다.

### 6.1) 프론트엔드(AST)

- [ ] lexer: 토큰 스트림(키워드/리터럴/스팬)
- [ ] parser: AST 생성
	- [ ] 표현식/문장/타입 노드 분리
	- [ ] 에러 복구(최소: `;`/`}` 싱크)
- [ ] AST pretty-printer(디버깅/테스트용)

### 6.2) 의미 분석(바인딩/타입)

- [ ] 심볼 테이블 + 스코프 해결
- [ ] 심볼 테이블 구현을 **해시맵(HashMap) 기반**으로 전환
	- [ ] 목표: `put/get/has`가 평균 O(1)로 동작
	- [ ] 스코프 처리: scope push/pop + shadowing 지원(동일 이름 재정의)
	- [ ] 구현 옵션(택1):
		- [ ] 스코프별 HashMap 스택(단순)
		- [ ] 단일 HashMap + undo 로그(스코프 pop 시 롤백)
- [ ] 타입 체크(최소 규칙부터)
- [ ] 제네릭 인스턴스화(타입 추론/치환)

### 6.3) IR 설계(최소부터)

초기 목표는 “코드젠이 쉬운 3-address/CFG 기반 IR”로 시작하고, 필요하면 SSA로 진화합니다.

- [ ] IR 기본 구조: Function / BasicBlock / Instruction
- [ ] 값 모델: virtual register(또는 SSA value) + 명시적 타입
- [ ] 메모리 모델: `alloca`/`load`/`store` 또는 “주소 + 폭” 중심의 명령
- [ ] control flow: `br`, `cbr`, `ret`, `switch`(또는 lowering)

### 6.3.5) IR 단계의 “필수 최적화”(제네릭 성능/정리)

제네릭 monomorphization 후에는 `sizeof(T)` 기반 상수/분기 등 “컴파일 타임으로 결정 가능한 것”이 많아진다.
IR에서 정리하지 않으면 코드가 급격히 비효율적이 된다.

- [ ] Constant Folding (상수 접기)
	- [ ] `1 + 2` → `3`
	- [ ] `if (true) { ... }` → 분기/블록 제거
- [ ] Dead Code Elimination (DCE)
	- [ ] 도달 불가능 코드 제거
	- [ ] 상수 분기 처리 후 남은 잔여 코드 청소

### 6.4) 백엔드(x86-64)

- [ ] IR → x86-64 lowering
- [ ] 레지스터 할당(최소: linear-scan)
- [ ] 스택 슬롯/스필(spill) 정책
- [ ] 호출 규약/ABI를 IR 레벨에서 명확히 표현(호출 전/후 보존 레지스터)
- [ ] `nospill` 제약 지원: spill이 필요하면 컴파일 에러

### 6.4.5) 다중 리턴(Multiple Return Values) (MVP: 2개까지만)

Go/System V 스타일로 “자주 쓰는 2-리턴 패턴(`val, ok` / `res, err`)”을 빠르게 지원한다.
ABI/성능/구현 난이도 관점에서, v3의 MVP는 **리턴값 2개까지만 레지스터로 반환**한다.

- [ ] 문법(함수 선언): `-> T`에 더해 튜플 반환 타입 지원
	- [ ] `func div_mod(a: u64, b: u64) -> (u64, u64) { ... }`
	- [ ] AST에 `return_types: [Type]` 형태로 저장
- [ ] 문법(return): `return a, b;` 형태 지원
	- [ ] 1개 리턴: 기존 `return expr;` 유지
	- [ ] 2개 리턴: `return expr0, expr1;`
- [ ] ABI 규칙(MVP)
	- [ ] 1번째 리턴 → `rax`
	- [ ] 2번째 리턴 → `rdx`
	- [ ] 3개 이상 리턴은 MVP에서 에러(또는 명시적 out-pointer 패턴으로 유도)
- [ ] 호출/바인딩(예: destructuring assign)
	- [ ] **선언+초기화**: `var q, r = div_mod(10, 3);` 지원
	- [ ] **기존 변수 대입**: `q, r = div_mod(10, 3);` 지원
	- [ ] 제약(MVP): 좌측항(L-value)은 **단순 식별자(IDENT)만 허용**
		- [ ] 허용: `a, b = f();`
		- [ ] 금지: `arr[i], *p = f();` / `p->x, q = f();` 등(주소 계산/부작용 순서 이슈)
	- [ ] 코드젠: call 후 `rax/rdx`를 각각 대상 슬롯에 저장
- [ ] IR 설계와의 접점
	- [ ] IR에서 multi-return을 직접 표현할지(예: `ret v0, v1`) 또는 호출 규약 레벨로 늦게 낮출지 결정
	- [ ] lowering 단계에서 `rax/rdx` 매핑이 일관되게 적용되도록 테스트

추가(후순위): 3개 이상 리턴은 “구조체 설탕(anonymous tuple struct) + hidden out pointer”로 확장 가능.

---

## 6.5) 디버깅 지원(삶의 질)

v2는 디버깅 시 어셈블리 라벨만 보고 추측해야 했다. v3는 최소한의 “위치 정보”를 끝까지 들고 간다.

- [ ] Location Info(Source Map) 전파
	- [ ] AST → IR → ASM 단계까지 파일/줄/컬럼(또는 span) 유지
	- [ ] 런타임 패닉 시 스택 트레이스 출력에 사용
	- [ ] (고급/후순위) asm에 `.loc` 넣어서 gdb 연동
- [ ] Panic 메커니즘
	- [ ] `panic("msg")` 내장 함수(또는 std 제공)
	- [ ] stderr 출력 + 종료(스택 정리 정책은 MVP에선 단순 종료도 허용)

---

## 7) 테스트/검증 전략(v3)

- [ ] 파서 스냅샷 테스트(AST pretty-print golden)
- [ ] IR 스냅샷 테스트(IR dump golden)
- [ ] e2e 스모크(Px): 작은 프로그램 컴파일→실행 exit code 검증
- [ ] 제네릭/컨테이너/foreach 폭 인식 등 핵심 기능별 스모크 추가
